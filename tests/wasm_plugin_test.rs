//! Integration tests for WASM plugin system

use conveyor::WasmPluginLoader;

#[tokio::test]
async fn test_wasm_plugin_loader_creation() {
    let loader = WasmPluginLoader::new();
    assert!(loader.is_ok(), "Failed to create WasmPluginLoader");
}

#[tokio::test]
#[ignore] // WASM plugin not built in CI
async fn test_load_echo_plugin() {
    let mut loader = WasmPluginLoader::new()
        .expect("Failed to create loader")
        .with_plugin_dir("target/wasm32-wasip2/release");

    let result = loader.load_plugin("echo").await;
    assert!(
        result.is_ok(),
        "Failed to load echo plugin: {:?}",
        result.err()
    );
}

#[tokio::test]
#[ignore] // WASM plugin not built in CI
async fn test_echo_plugin_metadata() {
    let mut loader = WasmPluginLoader::new()
        .expect("Failed to create loader")
        .with_plugin_dir("target/wasm32-wasip2/release");

    loader
        .load_plugin("echo")
        .await
        .expect("Failed to load plugin");

    let metadata = loader.get_plugin_metadata("echo");
    assert!(metadata.is_some(), "No metadata found for echo plugin");

    let meta = metadata.unwrap();
    assert_eq!(meta.name, "echo-wasm");
    assert_eq!(meta.version, "0.1.0");
    assert_eq!(meta.api_version, 1);
}

// Note: Read, write, transform, and validate_config operations require types
// which are generated by the bindgen macro and not easily accessible from tests.
// These operations are tested indirectly through the WasmPluginLoader implementation
// and will be fully tested when integrated into the pipeline.

#[tokio::test]
#[ignore] // WASM plugin not built in CI
async fn test_list_loaded_plugins() {
    let mut loader = WasmPluginLoader::new()
        .expect("Failed to create loader")
        .with_plugin_dir("target/wasm32-wasip2/release");

    assert_eq!(
        loader.list_plugins().len(),
        0,
        "Should start with no plugins"
    );

    loader
        .load_plugin("echo")
        .await
        .expect("Failed to load plugin");

    let plugins = loader.list_plugins();
    assert_eq!(plugins.len(), 1, "Should have 1 plugin loaded");
    assert!(plugins.contains(&"echo"), "Should contain 'echo' plugin");
}

#[tokio::test]
async fn test_load_nonexistent_plugin() {
    let mut loader = WasmPluginLoader::new()
        .expect("Failed to create loader")
        .with_plugin_dir("target/wasm32-wasip2/release");

    let result = loader.load_plugin("nonexistent").await;
    assert!(result.is_err(), "Loading nonexistent plugin should fail");
}

#[tokio::test]
#[ignore] // WASM plugin not built in CI
async fn test_multiple_plugins() {
    let mut loader = WasmPluginLoader::new()
        .expect("Failed to create loader")
        .with_plugin_dir("target/wasm32-wasip2/release");

    // Load multiple plugins (if they exist)
    let plugins = vec!["echo".to_string()];
    let result = loader.load_plugins(&plugins).await;
    assert!(
        result.is_ok(),
        "Loading multiple plugins failed: {:?}",
        result.err()
    );

    assert!(
        !loader.list_plugins().is_empty(),
        "Should have at least 1 plugin"
    );
}
